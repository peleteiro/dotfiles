#!/bin/bash
# Git commit message helper using Gemini CLI
# This script generates commit messages using Gemini based on git diff

# Pattern for matching code block markers (triple backticks with optional language)
# Using a variable to avoid shellcheck issues with backticks in strings
CODE_BLOCK_PATTERN='^```[a-z]*$'
TRIPLE_BACKTICK='```'
TRIPLE_BACKTICK_BASH='```bash'
TRIPLE_BACKTICK_SH='```sh'

# Function to check if a line is a code block marker
is_code_block_marker() {
  local line="$1"
  [ "$line" = "$TRIPLE_BACKTICK" ] || [ "$line" = "$TRIPLE_BACKTICK_BASH" ] || [ "$line" = "$TRIPLE_BACKTICK_SH" ] || echo "$line" | rg -q "$CODE_BLOCK_PATTERN" || false
}

# Function to check if a line starts a commit message (emoji + type:)
is_commit_message_start() {
  local line="$1"
  # Check if line starts with emoji followed by commit type (feat:, fix:, refactor:, etc.)
  echo "$line" | rg -q '^[âœ¨ğŸ›â™»ï¸ğŸ“âš¡ğŸ”§ğŸ¨ğŸš€ğŸ’„ğŸ”¥ğŸ’šğŸ”’ğŸ¯ğŸ—ï¸ğŸ“¦ğŸ‘·ğŸ”ğŸ’¡â™¿ğŸŒâ•â–ğŸ”€ğŸ“ˆğŸ“‰âœ…âŒğŸ”ğŸ¨ğŸš¨ğŸğŸ”¨ğŸŒ™âš™ï¸ğŸ‰][ \t]*[a-z]+:' || false
}

# Function to remove introductory text before the actual commit message
remove_intro_text() {
  local content="$1"
  local result=""
  local found_start=false
  local line_num=0

  while IFS= read -r line || [ -n "$line" ]; do
    line_num=$((line_num + 1))
    local trimmed_line
    trimmed_line=$(echo "$line" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

    # Skip empty lines at the beginning (before finding the start)
    if [ -z "$found_start" ] && [ -z "$trimmed_line" ]; then
      continue
    fi

    # Check if this line starts a commit message (emoji + type: or just type:)
    if [ -z "$found_start" ]; then
      # Check for common intro phrases and skip them
      if echo "$trimmed_line" | rg -qi '^(here is|the commit message|commit message is|generated commit|suggested commit|commit:|message:)' && [ "$line_num" -le 3 ]; then
        continue
      fi

      # Check if this line starts a commit message
      if is_commit_message_start "$trimmed_line"; then
        found_start=true
        result="$result$line"$'\n'
      # Also check for lines starting with just commit type (without emoji)
      elif echo "$trimmed_line" | rg -q '^(feat|fix|refactor|docs|perf|chore|style|test|build|ci|revert|wip|security|i18n|accessibility|config|deps|release|breaking):'; then
        found_start=true
        result="$result$line"$'\n'
      # If we're past line 3 and haven't found a clear start, assume this is the message
      elif [ "$line_num" -gt 3 ]; then
        found_start=true
        result="$result$line"$'\n'
      fi
    else
      # Once we found the start, keep everything
      result="$result$line"$'\n'
    fi
  done <<< "$content"

  echo "$result"
}

# Check if gemini CLI is available
if ! command -v gemini > /dev/null 2>&1; then
  # If gemini is not available, exit silently (don't break git commit)
  exit 0
fi

# Get the commit message file path
COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"
# shellcheck disable=SC2034  # SHA1 is provided by git hook but not used
SHA1="$3"

# Only generate message for new commits (not merges, amends, etc.)
# COMMIT_SOURCE can be: message, template, merge, squash, commit
# Empty COMMIT_SOURCE means it's a normal commit - generate message
# "message" means user provided -message flag, skip generation
# Other values (merge, squash, etc.) - skip generation
if [ "$COMMIT_SOURCE" = "message" ] || [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ] || [ "$COMMIT_SOURCE" = "commit" ]; then
  exit 0
fi

# Get the diff for the staged changes
DIFF=$(git diff --cached)

# If there's no diff, exit
if [ -z "$DIFF" ]; then
  exit 0
fi

# Save the original file content (including Git's comments with file listing)
ORIGINAL_CONTENT=""
COMMENTS_ONLY=""
if [ -f "$COMMIT_MSG_FILE" ]; then
  ORIGINAL_CONTENT=$(cat "$COMMIT_MSG_FILE")
  # Extract comments (lines starting with #) - these include the file listing
  COMMENTS_ONLY=$(echo "$ORIGINAL_CONTENT" | rg '^#' || true)

  # Check if message file already has non-comment content (user may have edited it)
  if [ -s "$COMMIT_MSG_FILE" ]; then
    # Check if there's any non-comment content
    NON_COMMENT_CONTENT=$(echo "$ORIGINAL_CONTENT" | rg -v '^#|^$' || true)
    if [ -n "$NON_COMMENT_CONTENT" ]; then
      # User has already written something, don't overwrite
      exit 0
    fi
  fi
fi

# Generate commit message using Gemini
# Read language from environment variable (default: en)
GIT_COMMIT_LANG="${GIT_COMMIT_LANG:-en}"

# Normalize language codes (only hardcoded rules: en -> en, pt -> pt-BR)
# For all other languages, use the code as-is
case "$GIT_COMMIT_LANG" in
  "pt"|"pt-BR"|"pt-br"|"pt_BR"|"pt_br")
    LANG_CODE="pt-BR"
    LANG_NAME="Portuguese (Brazilian)"
    ;;
  "en"|"en-US"|"en-us"|"en_US"|"en_us"|"")
    LANG_CODE="en"
    LANG_NAME="English (American)"
    ;;
  *)
    # For any other language, use the code as-is
    # Normalize common separators but keep the language code
    LANG_CODE=$(echo "$GIT_COMMIT_LANG" | tr '[:upper:]' '[:lower:]' | sd '_' '-')
    # Try to get language name from the code (basic mapping for common languages)
    case "$LANG_CODE" in
      "es"|"es-es"|"es-mx"|"es-ar") LANG_NAME="Spanish" ;;
      "fr"|"fr-fr"|"fr-ca") LANG_NAME="French" ;;
      "de"|"de-de"|"de-at") LANG_NAME="German" ;;
      "it"|"it-it") LANG_NAME="Italian" ;;
      "ja"|"ja-jp") LANG_NAME="Japanese" ;;
      "zh"|"zh-cn"|"zh-tw") LANG_NAME="Chinese" ;;
      "ru"|"ru-ru") LANG_NAME="Russian" ;;
      "ko"|"ko-kr") LANG_NAME="Korean" ;;
      *) LANG_NAME="$LANG_CODE" ;;  # Use code as name if unknown
    esac
    ;;
esac

# Create the prompt for Gemini - generic approach that works for any language
# Use English as the base prompt language and instruct Gemini to respond in the target language

# ------------------------------------------------------------------------------
# INTERACTIVE MODE: Ask user for context
# ------------------------------------------------------------------------------

# Temporary file for user input
USER_INTENT_FILE=$(mktemp "/tmp/git-commit-intent.XXXXXX")

# Add instructions to the file
cat > "$USER_INTENT_FILE" <<EOF


# ------------------------------------------------------------------------------
# ANTES DE GERAR O COMMIT:
# Descreva brevemente (em suas palavras) o que vocÃª fez e por quÃª.
# A IA usarÃ¡ isso como base para gerar a mensagem tÃ©cnica final.
#
# Exemplo: "Corrigi o erro de timeout na API de pagamentos"
#
# Deixe em branco se quiser que a IA analise sozinha pelo cÃ³digo.
# Linhas comeÃ§ando com '#' serÃ£o ignoradas.
# ------------------------------------------------------------------------------

EOF

# Determine the best editor to use
# 1. GIT_EDITOR (git specific)
# 2. VISUAL (standard visual editor)
# 3. EDITOR (standard editor)
# 4. code/vim/nano/vi (fallbacks)
if [ -n "$GIT_EDITOR" ]; then
  MY_EDITOR="$GIT_EDITOR"
elif [ -n "$VISUAL" ]; then
  MY_EDITOR="$VISUAL"
elif [ -n "$EDITOR" ]; then
  MY_EDITOR="$EDITOR"
else
  # Try to find a suitable editor
  if command -v code >/dev/null 2>&1; then
    MY_EDITOR="code --wait"
  elif command -v vim >/dev/null 2>&1; then
    MY_EDITOR="vim"
  elif command -v nano >/dev/null 2>&1; then
    MY_EDITOR="nano"
  else
    MY_EDITOR="vi"
  fi
fi

# Open editor for user input
# redirects are needed because git hooks might not have direct TTY access
eval "$MY_EDITOR" "$USER_INTENT_FILE" < /dev/tty > /dev/tty 2>&1

# Read user input, filtering out comments and empty lines
# Remove lines starting with # (even with leading whitespace) and empty lines
USER_INTENT=$(grep -v '^[ \t]*#' "$USER_INTENT_FILE" | grep -v '^[ \t]*$' | tr '\n' ' ' | sd '^[ \t]+' '' | sd '[ \t]+$' '')

# Cleanup
rm -f "$USER_INTENT_FILE"

# ------------------------------------------------------------------------------
# PROMPT CONSTRUCTION
# ------------------------------------------------------------------------------

PROMPT="Based on the following git diff, generate a detailed commit message following conventional commits format (type: description).

Requirements:
- Use conventional commits format (e.g., 'feat:', 'fix:', 'refactor:', 'docs:', etc.)
- Add appropriate emoji to the commit type (âœ¨ for feat, ğŸ› for fix, â™»ï¸ for refactor, ğŸ“ for docs, âš¡ for perf, ğŸ”§ for chore, etc.)
- Provide a clear and descriptive summary in the first line (max 72 characters)
- Include a blank line between the subject and body
- Include a detailed body explaining what was changed and why (if significant)
- Use bullet points (-) for multiple changes, with a blank line before the list
- Add a blank line between different sections if needed
- Keep all relevant information about the changes
- Do not remove comments or important details from the diff
- Write the commit message in $LANG_NAME ($LANG_CODE)"

# Add User Intent if provided
if [ -n "$USER_INTENT" ]; then
  PROMPT="$PROMPT

âš ï¸ CRITICAL - USER INTENT (HIGHEST PRIORITY):
The user has provided the following description of their changes. This is the PRIMARY source of information about the commit's purpose and intent. You MUST:
1. PRIORITIZE this user description above everything else, including the diff
2. Use this context as the foundation for understanding WHY the changes were made
3. Base the commit message summary and explanation primarily on this user intent
4. Use the diff only to fill in technical details and verify what was actually changed
5. If there's any conflict between the user intent and what appears in the diff, trust the user intent

User's description of their changes:
\"$USER_INTENT\""
fi

PROMPT="$PROMPT

Format example:
âœ¨ feat: add new feature

This commit adds a new feature that improves...

- Added new functionality
- Updated documentation
- Fixed related issues

Git diff:
$DIFF

CRITICAL OUTPUT REQUIREMENTS:
- Return ONLY the commit message itself, ready to use
- Do NOT include any introduction, explanation, or commentary before or after the message
- Do NOT write introductory phrases before the commit message
- Do NOT write descriptive text without the commit format
- The FIRST LINE of your output MUST start with an emoji followed by a commit type like âœ¨ feat, ğŸ› fix, or â™»ï¸ refactor
- The output must be the final commit message that will be used directly in git
- No additional text, no meta-commentary, just the formatted commit message
- Your output should start immediately with: [emoji] [type]: [description]

Example of correct output format (start your response exactly like this):
âœ¨ feat: add new feature

This commit adds...

Generate the complete commit message (subject and body if needed) in $LANG_NAME. Return ONLY the message starting with emoji and type, nothing else:"

# Call Gemini CLI with the prompt
# Gemini CLI accepts prompts via stdin or as positional arguments
# First try via stdin (better for long prompts with diff)
GEMINI_OUTPUT=$(echo "$PROMPT" | gemini 2>/dev/null)

# Extract the commit message, preserving multiple lines and comments
# Filter out only Gemini CLI metadata, but keep the actual message content
# Preserve blank lines (max 2 consecutive) for proper formatting
SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
  rg -v '^(Usage|Error|Warning|gemini):' || true | \
  sd '\n{4,}' '\n\n\n')  # Limit to max 3 consecutive blank lines

# Remove code block markers only from the beginning and end of the message
# Trim leading/trailing whitespace from the entire message (but preserve newlines and blank lines)
# Only trim spaces/tabs, not newlines
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
# Remove leading code block marker lines
FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
while is_code_block_marker "$FIRST_LINE"; do
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  [ -z "$FIRST_LINE" ] && break
done
# Remove trailing code block marker lines
LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
while is_code_block_marker "$LAST_LINE"; do
  LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
  if [ "$LINE_COUNT" -le 1 ]; then
    break
  fi
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  [ -z "$LAST_LINE" ] && break
done

# Remove any introductory text before the actual commit message
SUGGESTED_MSG=$(remove_intro_text "$SUGGESTED_MSG")

# Trim leading/trailing whitespace from each line but preserve structure
# Use sd to preserve newlines and blank lines properly (only trim spaces/tabs, not newlines)
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

# If that didn't work or output is too short, try passing the prompt as a positional argument
if [ -z "$SUGGESTED_MSG" ] || [ ${#SUGGESTED_MSG} -lt 10 ]; then
  # Truncate diff if too long (Gemini CLI may have argument length limits)
  DIFF_PREVIEW=$(echo "$DIFF" | head -n 100)

  # Use generic prompt for fallback too
  SHORT_PROMPT="Based on this git diff, generate a detailed commit message in conventional commits format (type: description).

Requirements:
- Use conventional commits format with emoji (âœ¨ feat, ğŸ› fix, â™»ï¸ refactor, ğŸ“ docs, etc.)
- First line: subject (max 72 chars) with emoji
- Blank line between subject and body
- Body with detailed explanation
- Use bullet points (-) for multiple changes
- Write in $LANG_NAME ($LANG_CODE)"

  # Add User Intent if provided (same priority as main prompt)
  if [ -n "$USER_INTENT" ]; then
    SHORT_PROMPT="$SHORT_PROMPT

âš ï¸ CRITICAL - USER INTENT (HIGHEST PRIORITY):
The user has provided the following description of their changes. This is the PRIMARY source of information about the commit's purpose and intent. You MUST:
1. PRIORITIZE this user description above everything else, including the diff
2. Use this context as the foundation for understanding WHY the changes were made
3. Base the commit message summary and explanation primarily on this user intent
4. Use the diff only to fill in technical details and verify what was actually changed
5. If there's any conflict between the user intent and what appears in the diff, trust the user intent

User's description of their changes:
\"$USER_INTENT\""
  fi

  SHORT_PROMPT="$SHORT_PROMPT

$DIFF_PREVIEW

CRITICAL OUTPUT REQUIREMENTS:
- Return ONLY the commit message itself, ready to use
- Do NOT include any introduction, explanation, or commentary before or after the message
- Do NOT write introductory phrases before the commit message
- Do NOT write descriptive text without the commit format
- The FIRST LINE of your output MUST start with an emoji followed by a commit type like âœ¨ feat, ğŸ› fix, or â™»ï¸ refactor
- The output must be the final commit message that will be used directly in git
- No additional text, no meta-commentary, just the formatted commit message
- Your output should start immediately with: [emoji] [type]: [description]

Example of correct output format (start your response exactly like this):
âœ¨ feat: add new feature

This commit adds...

Generate the complete commit message in $LANG_NAME. Return ONLY the message starting with emoji and type, nothing else:"

  GEMINI_OUTPUT=$(gemini "$SHORT_PROMPT" 2>/dev/null)
  SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
    rg -v '^(Usage|Error|Warning|gemini):' || true | \
    sd '\n{4,}' '\n\n\n')  # Limit to max 3 consecutive blank lines

  # Remove code block markers from beginning and end only
  # Trim leading/trailing whitespace (but preserve newlines and blank lines)
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
  # Remove leading code block marker lines
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  while is_code_block_marker "$FIRST_LINE"; do
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
    FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
    [ -z "$FIRST_LINE" ] && break
  done
  # Remove trailing code block marker lines
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  while is_code_block_marker "$LAST_LINE"; do
    LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
    if [ "$LINE_COUNT" -le 1 ]; then
      break
    fi
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
    LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
    [ -z "$LAST_LINE" ] && break
  done
  # Remove any introductory text before the actual commit message
  SUGGESTED_MSG=$(remove_intro_text "$SUGGESTED_MSG")

  # Trim leading/trailing whitespace from each line but preserve structure
  # Only trim spaces/tabs, not newlines (to preserve blank lines)
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
fi

# If we got a valid suggestion (at least 10 characters), write it to the commit message file
if [ -n "$SUGGESTED_MSG" ] && [ ${#SUGGESTED_MSG} -ge 10 ]; then
  # Create a backup of the original file (before we modify it)
  # This will be used by commit-msg hook to detect if user saved the file
  BACKUP_FILE="${COMMIT_MSG_FILE}.backup"
  if [ -f "$COMMIT_MSG_FILE" ]; then
    cp "$COMMIT_MSG_FILE" "$BACKUP_FILE"
  else
    touch "$BACKUP_FILE"
  fi

  # Write the suggested message, preserving Git's comments (file listing) below
  # This will update the commit message file's timestamp
  # Use printf '%b' to preserve newlines and escape sequences
  {
    printf '%b' "$SUGGESTED_MSG"
    printf '\n'
    # Add back the comments (file listing) if they exist
    if [ -n "$COMMENTS_ONLY" ]; then
      printf '%b' "$COMMENTS_ONLY"
    fi
  } > "$COMMIT_MSG_FILE"

  # Create a timestamp file AFTER writing the message
  # This marks when the message template was created
  # The timestamp file will be newer than the commit message file
  # When the user saves the file, the commit message file will become newer than the timestamp file
  TIMESTAMP_FILE="${COMMIT_MSG_FILE}.timestamp"
  # Use a small delay to ensure timestamp file is created after commit message file
  sleep 0.1
  touch "$TIMESTAMP_FILE"
fi

exit 0

