#!/bin/bash
# Git commit message helper using Gemini CLI
# This script generates commit messages using Gemini based on git diff

# Check if gemini CLI is available
if ! command -v gemini > /dev/null 2>&1; then
  # If gemini is not available, exit silently (don't break git commit)
  exit 0
fi

# Get the commit message file path
COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"
SHA1="$3"

# Only generate message for new commits (not merges, amends, etc.)
# COMMIT_SOURCE can be: message, template, merge, squash, commit
# Empty COMMIT_SOURCE means it's a normal commit - generate message
# "message" means user provided -message flag, skip generation
# Other values (merge, squash, etc.) - skip generation
if [ "$COMMIT_SOURCE" = "message" ] || [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ] || [ "$COMMIT_SOURCE" = "commit" ]; then
  exit 0
fi

# Get the diff for the staged changes
DIFF=$(git diff --cached)

# If there's no diff, exit
if [ -z "$DIFF" ]; then
  exit 0
fi

# Save the original file content (including Git's comments with file listing)
ORIGINAL_CONTENT=""
COMMENTS_ONLY=""
if [ -f "$COMMIT_MSG_FILE" ]; then
  ORIGINAL_CONTENT=$(cat "$COMMIT_MSG_FILE")
  # Extract comments (lines starting with #) - these include the file listing
  COMMENTS_ONLY=$(echo "$ORIGINAL_CONTENT" | grep "^#")
  
  # Check if message file already has non-comment content (user may have edited it)
  if [ -s "$COMMIT_MSG_FILE" ]; then
    # Check if there's any non-comment content
    NON_COMMENT_CONTENT=$(echo "$ORIGINAL_CONTENT" | grep -v "^#" | grep -v "^$" || true)
    if [ -n "$NON_COMMENT_CONTENT" ]; then
      # User has already written something, don't overwrite
      exit 0
    fi
  fi
fi

# Generate commit message using Gemini
# Read language from environment variable (default: en)
GIT_COMMIT_LANG="${GIT_COMMIT_LANG:-en}"

# Normalize language codes (only hardcoded rules: en -> en, pt -> pt-BR)
# For all other languages, use the code as-is
case "$GIT_COMMIT_LANG" in
  "pt"|"pt-BR"|"pt-br"|"pt_BR"|"pt_br")
    LANG_CODE="pt-BR"
    LANG_NAME="Portuguese (Brazilian)"
    ;;
  "en"|"en-US"|"en-us"|"en_US"|"en_us"|"")
    LANG_CODE="en"
    LANG_NAME="English (American)"
    ;;
  *)
    # For any other language, use the code as-is
    # Normalize common separators but keep the language code
    LANG_CODE=$(echo "$GIT_COMMIT_LANG" | tr '[:upper:]' '[:lower:]' | sed 's/_/-/g')
    # Try to get language name from the code (basic mapping for common languages)
    case "$LANG_CODE" in
      "es"|"es-es"|"es-mx"|"es-ar") LANG_NAME="Spanish" ;;
      "fr"|"fr-fr"|"fr-ca") LANG_NAME="French" ;;
      "de"|"de-de"|"de-at") LANG_NAME="German" ;;
      "it"|"it-it") LANG_NAME="Italian" ;;
      "ja"|"ja-jp") LANG_NAME="Japanese" ;;
      "zh"|"zh-cn"|"zh-tw") LANG_NAME="Chinese" ;;
      "ru"|"ru-ru") LANG_NAME="Russian" ;;
      "ko"|"ko-kr") LANG_NAME="Korean" ;;
      *) LANG_NAME="$LANG_CODE" ;;  # Use code as name if unknown
    esac
    ;;
esac

# Create the prompt for Gemini - generic approach that works for any language
# Use English as the base prompt language and instruct Gemini to respond in the target language
PROMPT="Based on the following git diff, generate a detailed commit message following conventional commits format (type: description).

Requirements:
- Use conventional commits format (e.g., 'feat:', 'fix:', 'refactor:', 'docs:', etc.)
- Provide a clear and descriptive summary in the first line
- Include a detailed body explaining what was changed and why (if significant)
- Keep all relevant information about the changes
- Do not remove comments or important details from the diff
- Write the commit message in $LANG_NAME ($LANG_CODE)

Git diff:
$DIFF

Generate the complete commit message (subject and body if needed) in $LANG_NAME:"

# Call Gemini CLI with the prompt
# Gemini CLI accepts prompts via stdin or as positional arguments
# First try via stdin (better for long prompts with diff)
GEMINI_OUTPUT=$(echo "$PROMPT" | gemini 2>/dev/null)

# Extract the commit message, preserving multiple lines and comments
# Filter out only Gemini CLI metadata, but keep the actual message content
SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
  grep -v "^Usage:" | \
  grep -v "^Error:" | \
  grep -v "^Warning:" | \
  grep -v "^gemini" | \
  awk 'BEGIN{blank=0} /^$/ {blank++; if(blank<=2) print} /./ {blank=0; print}')  # Keep max 2 consecutive blank lines

# Remove ``` only from the beginning and end of the message (not from the middle)
# Trim leading/trailing whitespace first
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
# Remove leading ``` lines
FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
while [ "$FIRST_LINE" = "```" ] || [ "$FIRST_LINE" = "```bash" ] || [ "$FIRST_LINE" = "```sh" ] || echo "$FIRST_LINE" | grep -q "^```[a-z]*$"; do
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  [ -z "$FIRST_LINE" ] && break
done
# Remove trailing ``` lines
LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
while [ "$LAST_LINE" = "```" ] || [ "$LAST_LINE" = "```bash" ] || [ "$LAST_LINE" = "```sh" ] || echo "$LAST_LINE" | grep -q "^```[a-z]*$"; do
  LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
  if [ "$LINE_COUNT" -le 1 ]; then
    break
  fi
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  [ -z "$LAST_LINE" ] && break
done

# Trim leading/trailing whitespace from each line but preserve structure
# (Already done above, but keeping for consistency)
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# If that didn't work or output is too short, try passing the prompt as a positional argument
if [ -z "$SUGGESTED_MSG" ] || [ ${#SUGGESTED_MSG} -lt 10 ]; then
  # Truncate diff if too long (Gemini CLI may have argument length limits)
  DIFF_PREVIEW=$(echo "$DIFF" | head -n 100)
  
  # Use generic prompt for fallback too
  SHORT_PROMPT="Based on this git diff, generate a detailed commit message in conventional commits format (type: description). Include a detailed body explaining the changes. Write the commit message in $LANG_NAME ($LANG_CODE):

$DIFF_PREVIEW

Generate the complete commit message in $LANG_NAME:"
  
  GEMINI_OUTPUT=$(gemini "$SHORT_PROMPT" 2>/dev/null)
  SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
    grep -v "^Usage:" | \
    grep -v "^Error:" | \
    grep -v "^Warning:" | \
    grep -v "^gemini" | \
    awk 'BEGIN{blank=0} /^$/ {blank++; if(blank<=2) print} /./ {blank=0; print}')
  
  # Remove ``` only from the beginning and end of the message (not from the middle)
  # Trim leading/trailing whitespace first
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
  # Remove leading ``` lines
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  while [ "$FIRST_LINE" = "```" ] || [ "$FIRST_LINE" = "```bash" ] || [ "$FIRST_LINE" = "```sh" ] || echo "$FIRST_LINE" | grep -q "^```[a-z]*$"; do
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
    FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
    [ -z "$FIRST_LINE" ] && break
  done
  # Remove trailing ``` lines
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  while [ "$LAST_LINE" = "```" ] || [ "$LAST_LINE" = "```bash" ] || [ "$LAST_LINE" = "```sh" ] || echo "$LAST_LINE" | grep -q "^```[a-z]*$"; do
    LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
    if [ "$LINE_COUNT" -le 1 ]; then
      break
    fi
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
    LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
    [ -z "$LAST_LINE" ] && break
  done
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
fi

# If we got a valid suggestion (at least 10 characters), write it to the commit message file
if [ -n "$SUGGESTED_MSG" ] && [ ${#SUGGESTED_MSG} -ge 10 ]; then
  # Create a backup of the original file (before we modify it)
  # This will be used by commit-msg hook to detect if user saved the file
  BACKUP_FILE="${COMMIT_MSG_FILE}.backup"
  if [ -f "$COMMIT_MSG_FILE" ]; then
    cp "$COMMIT_MSG_FILE" "$BACKUP_FILE"
  else
    touch "$BACKUP_FILE"
  fi
  
  # Write the suggested message, preserving Git's comments (file listing) below
  # This will update the commit message file's timestamp
  {
    echo "$SUGGESTED_MSG"
    echo ""
    # Add back the comments (file listing) if they exist
    if [ -n "$COMMENTS_ONLY" ]; then
      echo "$COMMENTS_ONLY"
    fi
  } > "$COMMIT_MSG_FILE"
  
  # Create a timestamp file AFTER writing the message
  # This marks when the message template was created
  # The timestamp file will be newer than the commit message file
  # When the user saves the file, the commit message file will become newer than the timestamp file
  TIMESTAMP_FILE="${COMMIT_MSG_FILE}.timestamp"
  # Use a small delay to ensure timestamp file is created after commit message file
  sleep 0.1
  touch "$TIMESTAMP_FILE"
fi

exit 0

