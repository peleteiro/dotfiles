#!/bin/bash
# Git commit message helper using Gemini CLI
# This script generates commit messages using Gemini based on git diff

# Pattern for matching code block markers (triple backticks with optional language)
# Using a variable to avoid shellcheck issues with backticks in strings
CODE_BLOCK_PATTERN='^```[a-z]*$'
TRIPLE_BACKTICK='```'
TRIPLE_BACKTICK_BASH='```bash'
TRIPLE_BACKTICK_SH='```sh'

# Function to check if a line is a code block marker
is_code_block_marker() {
  local line="$1"
  [ "$line" = "$TRIPLE_BACKTICK" ] || [ "$line" = "$TRIPLE_BACKTICK_BASH" ] || [ "$line" = "$TRIPLE_BACKTICK_SH" ] || echo "$line" | rg -q "$CODE_BLOCK_PATTERN" || false
}

# Check if gemini CLI is available
if ! command -v gemini > /dev/null 2>&1; then
  # If gemini is not available, exit silently (don't break git commit)
  exit 0
fi

# Get the commit message file path
COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"
# shellcheck disable=SC2034  # SHA1 is provided by git hook but not used
SHA1="$3"

# Only generate message for new commits (not merges, amends, etc.)
# COMMIT_SOURCE can be: message, template, merge, squash, commit
# Empty COMMIT_SOURCE means it's a normal commit - generate message
# "message" means user provided -message flag, skip generation
# Other values (merge, squash, etc.) - skip generation
if [ "$COMMIT_SOURCE" = "message" ] || [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ] || [ "$COMMIT_SOURCE" = "commit" ]; then
  exit 0
fi

# Get the diff for the staged changes
DIFF=$(git diff --cached)

# If there's no diff, exit
if [ -z "$DIFF" ]; then
  exit 0
fi

# Save the original file content (including Git's comments with file listing)
ORIGINAL_CONTENT=""
COMMENTS_ONLY=""
if [ -f "$COMMIT_MSG_FILE" ]; then
  ORIGINAL_CONTENT=$(cat "$COMMIT_MSG_FILE")
  # Extract comments (lines starting with #) - these include the file listing
  COMMENTS_ONLY=$(echo "$ORIGINAL_CONTENT" | rg '^#' || true)

  # Check if message file already has non-comment content (user may have edited it)
  if [ -s "$COMMIT_MSG_FILE" ]; then
    # Check if there's any non-comment content
    NON_COMMENT_CONTENT=$(echo "$ORIGINAL_CONTENT" | rg -v '^#|^$' || true)
    if [ -n "$NON_COMMENT_CONTENT" ]; then
      # User has already written something, don't overwrite
      exit 0
    fi
  fi
fi

# Generate commit message using Gemini
# Read language from environment variable (default: en)
GIT_COMMIT_LANG="${GIT_COMMIT_LANG:-en}"

# Normalize language codes (only hardcoded rules: en -> en, pt -> pt-BR)
# For all other languages, use the code as-is
case "$GIT_COMMIT_LANG" in
  "pt"|"pt-BR"|"pt-br"|"pt_BR"|"pt_br")
    LANG_CODE="pt-BR"
    LANG_NAME="Portuguese (Brazilian)"
    ;;
  "en"|"en-US"|"en-us"|"en_US"|"en_us"|"")
    LANG_CODE="en"
    LANG_NAME="English (American)"
    ;;
  *)
    # For any other language, use the code as-is
    # Normalize common separators but keep the language code
    LANG_CODE=$(echo "$GIT_COMMIT_LANG" | tr '[:upper:]' '[:lower:]' | sd '_' '-')
    # Try to get language name from the code (basic mapping for common languages)
    case "$LANG_CODE" in
      "es"|"es-es"|"es-mx"|"es-ar") LANG_NAME="Spanish" ;;
      "fr"|"fr-fr"|"fr-ca") LANG_NAME="French" ;;
      "de"|"de-de"|"de-at") LANG_NAME="German" ;;
      "it"|"it-it") LANG_NAME="Italian" ;;
      "ja"|"ja-jp") LANG_NAME="Japanese" ;;
      "zh"|"zh-cn"|"zh-tw") LANG_NAME="Chinese" ;;
      "ru"|"ru-ru") LANG_NAME="Russian" ;;
      "ko"|"ko-kr") LANG_NAME="Korean" ;;
      *) LANG_NAME="$LANG_CODE" ;;  # Use code as name if unknown
    esac
    ;;
esac

# Create the prompt for Gemini - generic approach that works for any language
# Use English as the base prompt language and instruct Gemini to respond in the target language

# ------------------------------------------------------------------------------
# INTERACTIVE MODE: Ask user for context
# ------------------------------------------------------------------------------

# Temporary file for user input
USER_INTENT_FILE=$(mktemp "/tmp/git-commit-intent.XXXXXX")

# Add instructions to the file
cat > "$USER_INTENT_FILE" <<EOF


# ------------------------------------------------------------------------------
# ANTES DE GERAR O COMMIT:
# Descreva brevemente (em suas palavras) o que vocÃª fez e por quÃª.
# A IA usarÃ¡ isso como base para gerar a mensagem tÃ©cnica final.
#
# Exemplo: "Corrigi o erro de timeout na API de pagamentos"
#
# Deixe em branco se quiser que a IA analise sozinha pelo cÃ³digo.
# Linhas comeÃ§ando com '#' serÃ£o ignoradas.
# ------------------------------------------------------------------------------

EOF

# Determine the best editor to use
# 1. GIT_EDITOR (git specific)
# 2. VISUAL (standard visual editor)
# 3. EDITOR (standard editor)
# 4. code/vim/nano/vi (fallbacks)
if [ -n "$GIT_EDITOR" ]; then
  MY_EDITOR="$GIT_EDITOR"
elif [ -n "$VISUAL" ]; then
  MY_EDITOR="$VISUAL"
elif [ -n "$EDITOR" ]; then
  MY_EDITOR="$EDITOR"
else
  # Try to find a suitable editor
  if command -v code >/dev/null 2>&1; then
    MY_EDITOR="code --wait"
  elif command -v vim >/dev/null 2>&1; then
    MY_EDITOR="vim"
  elif command -v nano >/dev/null 2>&1; then
    MY_EDITOR="nano"
  else
    MY_EDITOR="vi"
  fi
fi

# Open editor for user input
# redirects are needed because git hooks might not have direct TTY access
eval "$MY_EDITOR" "$USER_INTENT_FILE" < /dev/tty > /dev/tty 2>&1

# Read user input, filtering out comments and empty lines
USER_INTENT=$(grep -v "^#" "$USER_INTENT_FILE" | tr '\n' ' ' | sd '^[ \t]+' '' | sd '[ \t]+$' '')

# Cleanup
rm -f "$USER_INTENT_FILE"

# ------------------------------------------------------------------------------
# PROMPT CONSTRUCTION
# ------------------------------------------------------------------------------

PROMPT="Based on the following git diff, generate a detailed commit message following conventional commits format (type: description).

Requirements:
- Use conventional commits format (e.g., 'feat:', 'fix:', 'refactor:', 'docs:', etc.)
- Add appropriate emoji to the commit type (âœ¨ for feat, ðŸ› for fix, â™»ï¸ for refactor, ðŸ“ for docs, âš¡ for perf, ðŸ”§ for chore, etc.)
- Provide a clear and descriptive summary in the first line (max 72 characters)
- Include a blank line between the subject and body
- Include a detailed body explaining what was changed and why (if significant)
- Use bullet points (-) for multiple changes, with a blank line before the list
- Add a blank line between different sections if needed
- Keep all relevant information about the changes
- Do not remove comments or important details from the diff
- Write the commit message in $LANG_NAME ($LANG_CODE)"

# Add User Intent if provided
if [ -n "$USER_INTENT" ]; then
  PROMPT="$PROMPT

IMPORTANT - USER CONTEXT:
The user has provided the following description of their changes. You MUST use this to understand the INTENT and PURPOSE of the commit. Prioritize this context when writing the summary and explanation, while using the diff to fill in the technical details:
\"$USER_INTENT\""
fi

PROMPT="$PROMPT

Format example:
âœ¨ feat: add new feature

This commit adds a new feature that improves...

- Added new functionality
- Updated documentation
- Fixed related issues

Git diff:
$DIFF

Generate the complete commit message (subject and body if needed) in $LANG_NAME:"

# Call Gemini CLI with the prompt
# Gemini CLI accepts prompts via stdin or as positional arguments
# First try via stdin (better for long prompts with diff)
GEMINI_OUTPUT=$(echo "$PROMPT" | gemini 2>/dev/null)

# Extract the commit message, preserving multiple lines and comments
# Filter out only Gemini CLI metadata, but keep the actual message content
# Preserve blank lines (max 2 consecutive) for proper formatting
SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
  rg -v '^(Usage|Error|Warning|gemini):' || true | \
  sd '\n{4,}' '\n\n\n')  # Limit to max 3 consecutive blank lines

# Remove code block markers only from the beginning and end of the message
# Trim leading/trailing whitespace from the entire message (but preserve newlines and blank lines)
# Only trim spaces/tabs, not newlines
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
# Remove leading code block marker lines
FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
while is_code_block_marker "$FIRST_LINE"; do
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  [ -z "$FIRST_LINE" ] && break
done
# Remove trailing code block marker lines
LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
while is_code_block_marker "$LAST_LINE"; do
  LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
  if [ "$LINE_COUNT" -le 1 ]; then
    break
  fi
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  [ -z "$LAST_LINE" ] && break
done

# Trim leading/trailing whitespace from each line but preserve structure
# Use sd to preserve newlines and blank lines properly (only trim spaces/tabs, not newlines)
SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

# If that didn't work or output is too short, try passing the prompt as a positional argument
if [ -z "$SUGGESTED_MSG" ] || [ ${#SUGGESTED_MSG} -lt 10 ]; then
  # Truncate diff if too long (Gemini CLI may have argument length limits)
  DIFF_PREVIEW=$(echo "$DIFF" | head -n 100)

  # Use generic prompt for fallback too
  SHORT_PROMPT="Based on this git diff, generate a detailed commit message in conventional commits format (type: description).

Requirements:
- Use conventional commits format with emoji (âœ¨ feat, ðŸ› fix, â™»ï¸ refactor, ðŸ“ docs, etc.)
- First line: subject (max 72 chars) with emoji
- Blank line between subject and body
- Body with detailed explanation
- Use bullet points (-) for multiple changes
- Write in $LANG_NAME ($LANG_CODE)

$DIFF_PREVIEW

Generate the complete commit message in $LANG_NAME:"

  GEMINI_OUTPUT=$(gemini "$SHORT_PROMPT" 2>/dev/null)
  SUGGESTED_MSG=$(echo "$GEMINI_OUTPUT" | \
    rg -v '^(Usage|Error|Warning|gemini):' || true | \
    sd '\n{4,}' '\n\n\n')  # Limit to max 3 consecutive blank lines

  # Remove code block markers from beginning and end only
  # Trim leading/trailing whitespace (but preserve newlines and blank lines)
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
  # Remove leading code block marker lines
  FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
  while is_code_block_marker "$FIRST_LINE"; do
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | tail -n +2)
    FIRST_LINE=$(echo "$SUGGESTED_MSG" | head -n 1)
    [ -z "$FIRST_LINE" ] && break
  done
  # Remove trailing code block marker lines
  LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
  while is_code_block_marker "$LAST_LINE"; do
    LINE_COUNT=$(echo "$SUGGESTED_MSG" | wc -l | tr -d ' ')
    if [ "$LINE_COUNT" -le 1 ]; then
      break
    fi
    SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sed '$d')
    LAST_LINE=$(echo "$SUGGESTED_MSG" | tail -n 1)
    [ -z "$LAST_LINE" ] && break
  done
  # Trim leading/trailing whitespace from each line but preserve structure
  # Only trim spaces/tabs, not newlines (to preserve blank lines)
  SUGGESTED_MSG=$(echo "$SUGGESTED_MSG" | sd '^[ \t]+' '' | sd '[ \t]+$' '')
fi

# If we got a valid suggestion (at least 10 characters), write it to the commit message file
if [ -n "$SUGGESTED_MSG" ] && [ ${#SUGGESTED_MSG} -ge 10 ]; then
  # Create a backup of the original file (before we modify it)
  # This will be used by commit-msg hook to detect if user saved the file
  BACKUP_FILE="${COMMIT_MSG_FILE}.backup"
  if [ -f "$COMMIT_MSG_FILE" ]; then
    cp "$COMMIT_MSG_FILE" "$BACKUP_FILE"
  else
    touch "$BACKUP_FILE"
  fi

  # Write the suggested message, preserving Git's comments (file listing) below
  # This will update the commit message file's timestamp
  # Use printf '%b' to preserve newlines and escape sequences
  {
    printf '%b' "$SUGGESTED_MSG"
    printf '\n'
    # Add back the comments (file listing) if they exist
    if [ -n "$COMMENTS_ONLY" ]; then
      printf '%b' "$COMMENTS_ONLY"
    fi
  } > "$COMMIT_MSG_FILE"

  # Create a timestamp file AFTER writing the message
  # This marks when the message template was created
  # The timestamp file will be newer than the commit message file
  # When the user saves the file, the commit message file will become newer than the timestamp file
  TIMESTAMP_FILE="${COMMIT_MSG_FILE}.timestamp"
  # Use a small delay to ensure timestamp file is created after commit message file
  sleep 0.1
  touch "$TIMESTAMP_FILE"
fi

exit 0

