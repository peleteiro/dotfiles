#!/bin/bash
# Git commit message helper using AI (Gemini or Claude)
# This script generates commit messages using AI based on git diff
#
# Usage:
#   GIT_COMMIT_AI=gemini git commit  # use Gemini (default)
#   GIT_COMMIT_AI=claude git commit  # use Claude
#
# Set default in your shell: export GIT_COMMIT_AI=claude

# Pattern for matching code block markers (triple backticks with optional language)
# Using a variable to avoid shellcheck issues with backticks in strings
CODE_BLOCK_PATTERN='^```[a-z]*$'
TRIPLE_BACKTICK='```'
TRIPLE_BACKTICK_BASH='```bash'
TRIPLE_BACKTICK_SH='```sh'

# Function to check if a line is a code block marker
is_code_block_marker() {
  local line="$1"
  [ "$line" = "$TRIPLE_BACKTICK" ] || [ "$line" = "$TRIPLE_BACKTICK_BASH" ] || [ "$line" = "$TRIPLE_BACKTICK_SH" ] || echo "$line" | rg -q "$CODE_BLOCK_PATTERN" || false
}

# Function to check if a line starts a commit message (emoji + type:)
is_commit_message_start() {
  local line="$1"
  # Check if line starts with emoji followed by commit type (feat:, fix:, refactor:, etc.)
  echo "$line" | rg -q '^[âœ¨ğŸ›â™»ï¸ğŸ“âš¡ğŸ”§ğŸ¨ğŸš€ğŸ’„ğŸ”¥ğŸ’šğŸ”’ğŸ¯ğŸ—ï¸ğŸ“¦ğŸ‘·ğŸ”ğŸ’¡â™¿ğŸŒâ•â–ğŸ”€ğŸ“ˆğŸ“‰âœ…âŒğŸ”ğŸ¨ğŸš¨ğŸğŸ”¨ğŸŒ™âš™ï¸ğŸ‰][ \t]*[a-z]+:' || false
}

# Function to remove introductory text before the actual commit message
remove_intro_text() {
  local content="$1"
  local result=""
  local found_start=false
  local line_num=0

  while IFS= read -r line || [ -n "$line" ]; do
    line_num=$((line_num + 1))
    local trimmed_line
    trimmed_line=$(echo "$line" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

    # Skip empty lines at the beginning (before finding the start)
    if [ -z "$found_start" ] && [ -z "$trimmed_line" ]; then
      continue
    fi

    # Check if this line starts a commit message (emoji + type: or just type:)
    if [ -z "$found_start" ]; then
      # Check for common intro phrases and skip them
      if echo "$trimmed_line" | rg -qi '^(here is|the commit message|commit message is|generated commit|suggested commit|commit:|message:)' && [ "$line_num" -le 3 ]; then
        continue
      fi

      # Check if this line starts a commit message
      if is_commit_message_start "$trimmed_line"; then
        found_start=true
        result="$result$line"$'\n'
      # Also check for lines starting with just commit type (without emoji)
      elif echo "$trimmed_line" | rg -q '^(feat|fix|refactor|docs|perf|chore|style|test|build|ci|revert|wip|security|i18n|accessibility|config|deps|release|breaking):'; then
        found_start=true
        result="$result$line"$'\n'
      # If we're past line 3 and haven't found a clear start, assume this is the message
      elif [ "$line_num" -gt 3 ]; then
        found_start=true
        result="$result$line"$'\n'
      fi
    else
      # Once we found the start, keep everything
      result="$result$line"$'\n'
    fi
  done <<< "$content"

  echo "$result"
}

# Build context prompt sections (branch, scope, user intent)
# Usage: build_context_prompt [short]
# If "short" is passed, uses abbreviated format for fallback prompt
build_context_prompt() {
  local format="${1:-full}"
  local context=""

  # Add branch name context if available
  if [ -n "$BRANCH_NAME" ]; then
    if [ "$format" = "short" ]; then
      context="$context

Branch: '$BRANCH_NAME' (use as hint for intent)"
    else
      context="$context

BRANCH CONTEXT:
The current branch is: '$BRANCH_NAME'
Use this as a hint about the intent of the changes (e.g., 'feature/add-auth' suggests authentication feature, 'fix/login-bug' suggests a bug fix, 'refactor/cleanup-api' suggests refactoring)."
    fi
  fi

  # Add detected scope if available
  if [ -n "$DETECTED_SCOPE" ]; then
    if [ "$format" = "short" ]; then
      context="$context
Suggested scope: '$DETECTED_SCOPE' - consider using type($DETECTED_SCOPE): description"
    else
      context="$context

SUGGESTED SCOPE:
Based on the file paths, the suggested scope is: '$DETECTED_SCOPE'
Consider using this scope in the commit message format: type($DETECTED_SCOPE): description
Only use the scope if it makes sense for the changes. Skip it if changes span multiple unrelated areas."
    fi
  fi

  # Add User Intent if provided (same format for both)
  if [ -n "$USER_INTENT" ]; then
    context="$context

âš ï¸ CRITICAL - USER INTENT (HIGHEST PRIORITY):
The user has provided the following description of their changes. This is the PRIMARY source of information about the commit's purpose and intent. You MUST:
1. PRIORITIZE this user description above everything else, including the diff
2. Use this context as the foundation for understanding WHY the changes were made
3. Base the commit message summary and explanation primarily on this user intent
4. Use the diff only to fill in technical details and verify what was actually changed
5. If there's any conflict between the user intent and what appears in the diff, trust the user intent

User's description of their changes:
\"$USER_INTENT\""
  fi

  echo "$context"
}

# Process AI response: filter metadata, remove code blocks, clean up formatting
process_ai_response() {
  local ai_output="$1"
  local result=""

  # Filter out CLI metadata, preserve blank lines (max 2 consecutive)
  result=$(echo "$ai_output" | \
    rg -v '^(Usage|Error|Warning|gemini|claude):' || true | \
    sd '\n{4,}' '\n\n\n')

  # Trim leading/trailing whitespace (but preserve newlines)
  result=$(echo "$result" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

  # Remove leading code block marker lines
  local first_line
  first_line=$(echo "$result" | head -n 1)
  while is_code_block_marker "$first_line"; do
    result=$(echo "$result" | tail -n +2)
    first_line=$(echo "$result" | head -n 1)
    [ -z "$first_line" ] && break
  done

  # Remove trailing code block marker lines
  local last_line
  last_line=$(echo "$result" | tail -n 1)
  while is_code_block_marker "$last_line"; do
    local line_count
    line_count=$(echo "$result" | wc -l | tr -d ' ')
    if [ "$line_count" -le 1 ]; then
      break
    fi
    result=$(echo "$result" | sed '$d')
    last_line=$(echo "$result" | tail -n 1)
    [ -z "$last_line" ] && break
  done

  # Remove introductory text before the actual commit message
  result=$(remove_intro_text "$result")

  # Final trim of whitespace
  result=$(echo "$result" | sd '^[ \t]+' '' | sd '[ \t]+$' '')

  echo "$result"
}

# ------------------------------------------------------------------------------
# AI PROVIDER FUNCTIONS
# ------------------------------------------------------------------------------

# Select AI provider (default: gemini)
AI_PROVIDER="${GIT_COMMIT_AI:-gemini}"

# Call Gemini CLI with a prompt
call_gemini() {
  local prompt="$1"
  if ! command -v gemini > /dev/null 2>&1; then
    return 1
  fi
  echo "$prompt" | gemini 2>/dev/null
}

# Call Claude CLI with a prompt
call_claude() {
  local prompt="$1"
  if ! command -v claude > /dev/null 2>&1; then
    return 1
  fi
  # Claude CLI accepts prompts via --print flag for non-interactive output
  echo "$prompt" | claude --print 2>/dev/null
}

# Dispatch to the selected AI provider with fallback
call_ai() {
  local prompt="$1"
  local output=""

  case "$AI_PROVIDER" in
    "claude")
      output=$(call_claude "$prompt")
      if [ -z "$output" ] || [ ${#output} -lt 10 ]; then
        # Fallback to gemini if claude fails
        output=$(call_gemini "$prompt")
      fi
      ;;
    "gemini"|*)
      output=$(call_gemini "$prompt")
      if [ -z "$output" ] || [ ${#output} -lt 10 ]; then
        # Fallback to claude if gemini fails
        output=$(call_claude "$prompt")
      fi
      ;;
  esac

  echo "$output"
}

# Check if at least one AI provider is available
if ! command -v gemini > /dev/null 2>&1 && ! command -v claude > /dev/null 2>&1; then
  # No AI provider available, exit silently (don't break git commit)
  exit 0
fi

# Get the commit message file path
COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"
# shellcheck disable=SC2034  # SHA1 is provided by git hook but not used
SHA1="$3"

# Only generate message for new commits (not merges, amends, etc.)
# COMMIT_SOURCE can be: message, template, merge, squash, commit
# Empty COMMIT_SOURCE means it's a normal commit - generate message
# "message" means user provided -message flag, skip generation
# Other values (merge, squash, etc.) - skip generation
if [ "$COMMIT_SOURCE" = "message" ] || [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ] || [ "$COMMIT_SOURCE" = "commit" ]; then
  exit 0
fi

# Get the diff for the staged changes
DIFF_FULL=$(git diff --cached)

# If there's no diff, exit
if [ -z "$DIFF_FULL" ]; then
  exit 0
fi

# Truncate diff if too large to avoid "Prompt is too long" errors
# Gemini has ~32k token limit, Claude similar. Limit to ~500 lines or ~20000 chars
MAX_DIFF_LINES=500
MAX_DIFF_CHARS=20000

DIFF_LINES=$(echo "$DIFF_FULL" | wc -l | tr -d ' ')
DIFF_CHARS=${#DIFF_FULL}

if [ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ] || [ "$DIFF_CHARS" -gt "$MAX_DIFF_CHARS" ]; then
  # Truncate to max lines
  DIFF=$(echo "$DIFF_FULL" | head -n "$MAX_DIFF_LINES")
  DIFF_TRUNCATED=true
else
  DIFF="$DIFF_FULL"
  DIFF_TRUNCATED=false
fi

# ------------------------------------------------------------------------------
# CONTEXT EXTRACTION: Branch name and scope detection
# ------------------------------------------------------------------------------

# Get current branch name for context
BRANCH_NAME=$(git branch --show-current 2>/dev/null || echo "")

# Get list of changed files to detect scope
CHANGED_FILES=$(git diff --cached --name-only)

# Function to detect common scope from file paths
detect_scope() {
  local files="$1"
  local common_dir=""
  local file_count=0
  local first_dir=""

  while IFS= read -r file; do
    [ -z "$file" ] && continue
    file_count=$((file_count + 1))

    # Get the first directory component (or filename if in root)
    local dir
    dir=$(echo "$file" | cut -d'/' -f1)

    # For deeper paths, try to get a meaningful scope
    # e.g., src/components/auth/Login.tsx -> "auth"
    # e.g., src/auth/login.ts -> "auth"
    local deep_dir=""
    if echo "$file" | grep -q '/'; then
      # Try to find a meaningful directory (skip common top-level dirs)
      deep_dir=$(echo "$file" | sd '^(src|lib|app|packages|modules)/' '' | cut -d'/' -f1)
      # If deep_dir is a file (has extension), use parent logic
      if echo "$deep_dir" | grep -q '\.'; then
        deep_dir=""
      fi
    fi

    local effective_dir="${deep_dir:-$dir}"

    if [ -z "$first_dir" ]; then
      first_dir="$effective_dir"
      common_dir="$effective_dir"
    elif [ "$effective_dir" != "$common_dir" ]; then
      # Different directories, no common scope
      common_dir=""
    fi
  done <<< "$files"

  # Only suggest scope if we have multiple files in the same directory
  # or a single file in a meaningful directory
  if [ -n "$common_dir" ] && [ "$file_count" -ge 1 ]; then
    # Clean up scope name (lowercase, no special chars)
    echo "$common_dir" | tr '[:upper:]' '[:lower:]' | sd '[^a-z0-9-]' ''
  fi
}

DETECTED_SCOPE=$(detect_scope "$CHANGED_FILES")

# Save the original file content (including Git's comments with file listing)
ORIGINAL_CONTENT=""
COMMENTS_ONLY=""
if [ -f "$COMMIT_MSG_FILE" ]; then
  ORIGINAL_CONTENT=$(cat "$COMMIT_MSG_FILE")
  # Extract comments (lines starting with #) - these include the file listing
  COMMENTS_ONLY=$(echo "$ORIGINAL_CONTENT" | rg '^#' || true)

  # Check if message file already has non-comment content (user may have edited it)
  if [ -s "$COMMIT_MSG_FILE" ]; then
    # Check if there's any non-comment content
    NON_COMMENT_CONTENT=$(echo "$ORIGINAL_CONTENT" | rg -v '^#|^$' || true)
    if [ -n "$NON_COMMENT_CONTENT" ]; then
      # User has already written something, don't overwrite
      exit 0
    fi
  fi
fi

# Generate commit message using Gemini
# Read language from environment variable (default: en)
GIT_COMMIT_LANG="${GIT_COMMIT_LANG:-en}"

# Normalize language codes (only hardcoded rules: en -> en, pt -> pt-BR)
# For all other languages, use the code as-is
case "$GIT_COMMIT_LANG" in
  "pt"|"pt-BR"|"pt-br"|"pt_BR"|"pt_br")
    LANG_CODE="pt-BR"
    LANG_NAME="Portuguese (Brazilian)"
    ;;
  "en"|"en-US"|"en-us"|"en_US"|"en_us"|"")
    LANG_CODE="en"
    LANG_NAME="English (American)"
    ;;
  *)
    # For any other language, use the code as-is
    # Normalize common separators but keep the language code
    LANG_CODE=$(echo "$GIT_COMMIT_LANG" | tr '[:upper:]' '[:lower:]' | sd '_' '-')
    # Try to get language name from the code (basic mapping for common languages)
    case "$LANG_CODE" in
      "es"|"es-es"|"es-mx"|"es-ar") LANG_NAME="Spanish" ;;
      "fr"|"fr-fr"|"fr-ca") LANG_NAME="French" ;;
      "de"|"de-de"|"de-at") LANG_NAME="German" ;;
      "it"|"it-it") LANG_NAME="Italian" ;;
      "ja"|"ja-jp") LANG_NAME="Japanese" ;;
      "zh"|"zh-cn"|"zh-tw") LANG_NAME="Chinese" ;;
      "ru"|"ru-ru") LANG_NAME="Russian" ;;
      "ko"|"ko-kr") LANG_NAME="Korean" ;;
      *) LANG_NAME="$LANG_CODE" ;;  # Use code as name if unknown
    esac
    ;;
esac

# Create the prompt for Gemini - generic approach that works for any language
# Use English as the base prompt language and instruct Gemini to respond in the target language

# ------------------------------------------------------------------------------
# INTERACTIVE MODE: Ask user for context
# ------------------------------------------------------------------------------

# Temporary file for user input
USER_INTENT_FILE=$(mktemp "/tmp/git-commit-intent.XXXXXX")

# Add instructions to the file
cat > "$USER_INTENT_FILE" <<'EOF'


# ------------------------------------------------------------------------------
# BEFORE GENERATING THE COMMIT:
# Briefly describe (in your own words) what you did and why.
# The AI will use this as the basis for generating the final technical message.
#
# Example: "Fixed the timeout error in the payments API"
#
# Leave blank if you want the AI to analyze the code on its own.
# Lines starting with '#' will be ignored.
# ------------------------------------------------------------------------------

EOF

# Determine the best editor to use
# 1. GIT_EDITOR (git specific)
# 2. VISUAL (standard visual editor)
# 3. EDITOR (standard editor)
# 4. code/vim/nano/vi (fallbacks)
if [ -n "$GIT_EDITOR" ]; then
  MY_EDITOR="$GIT_EDITOR"
elif [ -n "$VISUAL" ]; then
  MY_EDITOR="$VISUAL"
elif [ -n "$EDITOR" ]; then
  MY_EDITOR="$EDITOR"
else
  # Try to find a suitable editor
  if command -v code >/dev/null 2>&1; then
    MY_EDITOR="code --wait"
  elif command -v vim >/dev/null 2>&1; then
    MY_EDITOR="vim"
  elif command -v nano >/dev/null 2>&1; then
    MY_EDITOR="nano"
  else
    MY_EDITOR="vi"
  fi
fi

# Open editor for user input
# redirects are needed because git hooks might not have direct TTY access
eval "$MY_EDITOR" "$USER_INTENT_FILE" < /dev/tty > /dev/tty 2>&1

# Read user input, filtering out comments and empty lines
# Remove lines starting with # (even with leading whitespace) and empty lines
USER_INTENT=$(grep -v '^[ \t]*#' "$USER_INTENT_FILE" | grep -v '^[ \t]*$' | tr '\n' ' ' | sd '^[ \t]+' '' | sd '[ \t]+$' '')

# Cleanup
rm -f "$USER_INTENT_FILE"

# ------------------------------------------------------------------------------
# PROMPT CONSTRUCTION
# ------------------------------------------------------------------------------

PROMPT="Based on the following git diff, perform a DEEP ANALYSIS of the changes and generate a comprehensive commit message following conventional commits format (type: description).

ANALYSIS REQUIREMENTS:
- Carefully analyze EVERY file modified, added, or deleted
- Understand the PURPOSE and IMPACT of each change
- Identify patterns, refactorings, bug fixes, and new features
- Consider how changes relate to each other
- Note any breaking changes, dependencies, or side effects

MESSAGE REQUIREMENTS:
- Use conventional commits format (e.g., 'feat:', 'fix:', 'refactor:', 'docs:', etc.)
- Add appropriate emoji to the commit type (âœ¨ for feat, ğŸ› for fix, â™»ï¸ for refactor, ğŸ“ for docs, âš¡ for perf, ğŸ”§ for chore, etc.)
- Provide a clear and descriptive summary in the first line (max 72 characters)
- Include a blank line between the subject and body
- Include a detailed body explaining what was changed and WHY (context and motivation)
- Use bullet points (-) for multiple changes - USE AS MANY AS NEEDED (up to 20 bullet points if the changes warrant it)
- Group related changes by CATEGORY when there are many changes. Use sections like:
  * Changes: (for code changes, new features, modifications)
  * Tests: (for test additions or modifications)
  * Documentation: (for docs, comments, README updates)
  * Refactor: (for code restructuring without behavior change)
  * Dependencies: (for package/dependency updates)
- Be thorough: do NOT omit important changes just to keep the message short
- Add a blank line between different sections if needed
- Keep all relevant information about the changes
- Do not remove comments or important details from the diff
- Write the commit message in $LANG_NAME ($LANG_CODE)"

# Add context (branch, scope, user intent)
PROMPT="$PROMPT$(build_context_prompt full)

Format examples:

Example 1 (feature with categories):
âœ¨ feat: add user authentication system

This commit introduces a complete authentication system to improve security.
The motivation was to replace the legacy session-based auth with JWT tokens.

Changes:
- Added JWT token generation and validation
- Implemented login/logout endpoints
- Created middleware for protected routes
- Added password hashing with bcrypt

Tests:
- Added unit tests for token validation
- Added integration tests for auth flow

Documentation:
- Updated API docs with auth endpoints
- Added examples for token usage

Example 2 (bug fix):
ğŸ› fix: resolve race condition in payment processing

Fixed a critical bug where concurrent payment requests could result in
duplicate charges due to missing database locks.

- Added row-level locking on payment records
- Implemented idempotency keys for retry safety
- Added transaction rollback on timeout

Example 3 (refactor):
â™»ï¸ refactor: simplify error handling across API

Consolidated scattered try-catch blocks into a centralized error handler
to improve maintainability and consistent error responses.

Refactor:
- Extracted common error handling to middleware
- Standardized error response format
- Removed redundant try-catch blocks in controllers

Tests:
- Updated tests to use new error format

Git diff${DIFF_TRUNCATED:+ (truncated - showing first $MAX_DIFF_LINES lines of $DIFF_LINES)}:
$DIFF

CRITICAL OUTPUT REQUIREMENTS:
- Return ONLY the commit message itself, ready to use
- Do NOT include any introduction, explanation, or commentary before or after the message
- Do NOT write introductory phrases before the commit message
- Do NOT write descriptive text without the commit format
- The FIRST LINE of your output MUST start with an emoji followed by a commit type like âœ¨ feat, ğŸ› fix, or â™»ï¸ refactor
- The output must be the final commit message that will be used directly in git
- No additional text, no meta-commentary, just the formatted commit message
- Your output should start immediately with: [emoji] [type]: [description]

Example of correct output format (start your response exactly like this):
âœ¨ feat: add new feature

This commit adds...

Generate the complete commit message (subject and body if needed) in $LANG_NAME. Return ONLY the message starting with emoji and type, nothing else:"

# Call AI provider and process response
AI_OUTPUT=$(call_ai "$PROMPT")
SUGGESTED_MSG=$(process_ai_response "$AI_OUTPUT")

# If that didn't work or output is too short, try with a more aggressively truncated diff
if [ -z "$SUGGESTED_MSG" ] || [ ${#SUGGESTED_MSG} -lt 10 ]; then
  # Use a much smaller diff for the fallback (100 lines max)
  DIFF_PREVIEW=$(echo "$DIFF_FULL" | head -n 100)

  # Use generic prompt for fallback too
  SHORT_PROMPT="Based on this git diff, perform a DEEP ANALYSIS and generate a comprehensive commit message in conventional commits format (type: description).

Requirements:
- Analyze EVERY change carefully - understand PURPOSE and IMPACT
- Use conventional commits format with emoji (âœ¨ feat, ğŸ› fix, â™»ï¸ refactor, ğŸ“ docs, etc.)
- First line: subject (max 72 chars) with emoji
- Blank line between subject and body
- Body with detailed explanation of WHAT and WHY
- Use bullet points (-) for multiple changes - up to 20 if needed
- Group changes by category when many: Changes:, Tests:, Documentation:, Refactor:, Dependencies:
- Be thorough: do NOT omit important changes
- Write in $LANG_NAME ($LANG_CODE)$(build_context_prompt short)

Git diff (truncated to first 100 lines for brevity):
$DIFF_PREVIEW

CRITICAL OUTPUT REQUIREMENTS:
- Return ONLY the commit message itself, ready to use
- Do NOT include any introduction, explanation, or commentary before or after the message
- Do NOT write introductory phrases before the commit message
- Do NOT write descriptive text without the commit format
- The FIRST LINE of your output MUST start with an emoji followed by a commit type like âœ¨ feat, ğŸ› fix, or â™»ï¸ refactor
- The output must be the final commit message that will be used directly in git
- No additional text, no meta-commentary, just the formatted commit message
- Your output should start immediately with: [emoji] [type]: [description]

Example of correct output format (start your response exactly like this):
âœ¨ feat: add new feature

This commit adds...

Generate the complete commit message in $LANG_NAME. Return ONLY the message starting with emoji and type, nothing else:"

  AI_OUTPUT=$(call_ai "$SHORT_PROMPT")
  SUGGESTED_MSG=$(process_ai_response "$AI_OUTPUT")
fi

# If we got a valid suggestion (at least 10 characters), write it to the commit message file
if [ -n "$SUGGESTED_MSG" ] && [ ${#SUGGESTED_MSG} -ge 10 ]; then
  # Create a backup of the original file (before we modify it)
  # This will be used by commit-msg hook to detect if user saved the file
  BACKUP_FILE="${COMMIT_MSG_FILE}.backup"
  if [ -f "$COMMIT_MSG_FILE" ]; then
    cp "$COMMIT_MSG_FILE" "$BACKUP_FILE"
  else
    touch "$BACKUP_FILE"
  fi

  # Write the suggested message, preserving Git's comments (file listing) below
  # This will update the commit message file's timestamp
  # Use printf '%b' to preserve newlines and escape sequences
  {
    printf '%b' "$SUGGESTED_MSG"
    printf '\n'
    # Add back the comments (file listing) if they exist
    if [ -n "$COMMENTS_ONLY" ]; then
      printf '%b' "$COMMENTS_ONLY"
    fi
  } > "$COMMIT_MSG_FILE"

  # Create a timestamp file AFTER writing the message
  # This marks when the message template was created
  # The timestamp file will be newer than the commit message file
  # When the user saves the file, the commit message file will become newer than the timestamp file
  TIMESTAMP_FILE="${COMMIT_MSG_FILE}.timestamp"
  # Use a small delay to ensure timestamp file is created after commit message file
  sleep 0.1
  touch "$TIMESTAMP_FILE"
fi

exit 0

