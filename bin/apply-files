#!/bin/bash
# Script to copy dotfiles to home directory
# Supports Bash and Zsh

set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"

# Detect operating system
OS=$(uname)
if [ "$OS" = "Darwin" ]; then
  CURRENT_OS="macos"
  OTHER_OS="linux"
else
  CURRENT_OS="linux"
  OTHER_OS="macos"
fi

echo "ðŸ“ Copying dotfiles to $HOME..."

# List of files that should keep their OS suffix (they are referenced/included by other files)
# These files are sourced/included by other configuration files
KEEP_SUFFIX_FILES=(
  ".bash_profile-${CURRENT_OS}"
  ".shared_shell_config-${CURRENT_OS}"
)

# Copy dotfiles
echo "  Copying files..."
find "$DIR/home" -maxdepth 1 -type f -name ".*" -print0 | while IFS= read -r -d '' file; do
  filename=$(basename "$file")
  
  # Skip gitconfig files - will be assembled separately
  if [[ "$filename" == ".gitconfig"* ]]; then
    continue
  fi
  
  # Skip files with OS suffix from the other OS
  if [[ "$filename" == *"-${OTHER_OS}" ]]; then
    continue
  fi
  
  # Handle files with OS suffix for current OS
  if [[ "$filename" == *"-${CURRENT_OS}" ]]; then
    # Check if this file should keep its suffix (it's referenced by another file)
    keep_suffix=false
    for keep_file in "${KEEP_SUFFIX_FILES[@]}"; do
      if [ "$filename" = "$keep_file" ]; then
        keep_suffix=true
        break
      fi
    done
    
    if [ "$keep_suffix" = true ]; then
      # Copy with suffix (file is referenced by another file)
      echo "    â†’ $filename"
      cp "$file" "$HOME/$filename"
    else
      # Copy without suffix (remove the OS suffix)
      target_filename="${filename%-"${CURRENT_OS}"}"
      echo "    â†’ $target_filename (from $filename)"
      cp "$file" "$HOME/$target_filename"
    fi
  else
    # Regular file without OS suffix
  echo "    â†’ $filename"
  cp "$file" "$HOME/$filename"
  fi
done

# Assemble .gitconfig based on GUI availability
echo "  Configuring Git..."
HAS_GUI=false
if [ -n "$DISPLAY" ] || [ -n "$WAYLAND_DISPLAY" ]; then
  HAS_GUI=true
elif [[ "$(uname)" == "Darwin" ]]; then
  # macOS always has GUI capability
  HAS_GUI=true
fi

# Build .gitconfig from base + appropriate GUI/non-GUI config
if [ -f "$DIR/home/.gitconfig-base" ]; then
  cp "$DIR/home/.gitconfig-base" "$HOME/.gitconfig"
  
  if [ "$HAS_GUI" = true ]; then
    if [ -f "$DIR/home/.gitconfig-gui" ]; then
      cat "$DIR/home/.gitconfig-gui" >> "$HOME/.gitconfig"
      echo "    â†’ Git configured for graphical environment"
    fi
  else
    if [ -f "$DIR/home/.gitconfig-nogui" ]; then
      cat "$DIR/home/.gitconfig-nogui" >> "$HOME/.gitconfig"
      echo "    â†’ Git configured for CLI-only environment"
    fi
  fi
  echo "    â†’ .gitconfig"
fi

# Function to copy directory recursively, handling OS-specific files
copy_dir_recursive() {
  local source_dir="$1"
  local dest_dir="$2"
  
  # Create destination directory
  mkdir -p "$dest_dir"
  
  # Process all items in source directory
  find "$source_dir" -mindepth 1 -maxdepth 1 -print0 | while IFS= read -r -d '' item; do
    itemname=$(basename "$item")
    
    if [ -d "$item" ]; then
      # Recursively copy subdirectories
      copy_dir_recursive "$item" "$dest_dir/$itemname"
    elif [ -f "$item" ]; then
      # Skip files with OS suffix from the other OS
      if [[ "$itemname" == *"-${OTHER_OS}" ]]; then
        continue
      fi
      
      # Handle files with OS suffix for current OS - copy without suffix
      if [[ "$itemname" == *"-${CURRENT_OS}" ]]; then
        target_filename="${itemname%-"${CURRENT_OS}"}"
        cp "$item" "$dest_dir/$target_filename"
      else
        # Regular file without OS suffix
        cp "$item" "$dest_dir/$itemname"
      fi
    fi
  done
}

# Copy dotfile directories
echo "  Copying directories..."
find "$DIR/home" -maxdepth 1 -type d -name ".*" -print0 | while IFS= read -r -d '' dir; do
  dirname=$(basename "$dir")
  if [ "$dirname" != "." ] && [ "$dirname" != ".." ]; then
    # Skip .my-git-hooks - it's handled separately in the Git hooks setup section
    if [ "$dirname" = ".my-git-hooks" ]; then
      continue
    fi
    echo "    â†’ $dirname/"
    copy_dir_recursive "$dir" "$HOME/$dirname"
    
    # Set correct permissions for .ssh directory
    if [ "$dirname" = ".ssh" ]; then
      chmod 700 "$HOME/.ssh"
      if [ -f "$HOME/.ssh/config" ]; then
        chmod 600 "$HOME/.ssh/config"
        # Replace ~/Library/Group Containers with absolute path for IdentityAgent
        # SSH config needs absolute path when there are spaces in the path
        if grep -q 'IdentityAgent "~/Library/Group Containers' "$HOME/.ssh/config"; then
          sed -i.bak "s|IdentityAgent \"~/Library/Group Containers|IdentityAgent \"$HOME/Library/Group Containers|g" "$HOME/.ssh/config"
          rm -f "$HOME/.ssh/config.bak"
        fi
        echo "    â†’ SSH config configured for ${CURRENT_OS}"
      fi
    fi
    
    # Set correct permissions for .gnupg directory
    if [ "$dirname" = ".gnupg" ]; then
      chmod 700 "$HOME/.gnupg"
      if [ -f "$HOME/.gnupg/gpg-agent.conf" ]; then
        chmod 600 "$HOME/.gnupg/gpg-agent.conf"
        # Replace ~/.bin/pinentry-1password with absolute path
        if grep -q "pinentry-program ~/.bin/pinentry-1password" "$HOME/.gnupg/gpg-agent.conf"; then
          sed -i.bak "s|pinentry-program ~/.bin/pinentry-1password|pinentry-program $HOME/.bin/pinentry-1password|g" "$HOME/.gnupg/gpg-agent.conf"
          rm -f "$HOME/.gnupg/gpg-agent.conf.bak"
        fi
      fi
    fi
    
    # Set correct permissions for .bin directory (make scripts executable)
    if [ "$dirname" = ".bin" ]; then
      chmod 755 "$HOME/.bin"
      find "$HOME/.bin" -type f -exec chmod +x {} \;
      echo "    â†’ Scripts in .bin made executable"
    fi
  fi
done

# Setup Git hooks directory and prepare-commit-msg hook (global for all repos)
echo "  Setting up Git hooks..."
GIT_HOOKS_DIR="$HOME/.my-git-hooks"
mkdir -p "$GIT_HOOKS_DIR"

# Source directory for git hooks
GIT_HOOKS_SOURCE="$DIR/home/.my-git-hooks"

if [ -f "$HOME/.bin/git-commit-msg-gemini" ] && [ -d "$GIT_HOOKS_SOURCE" ]; then
  # Copy git hooks from source directory
  if [ -f "$GIT_HOOKS_SOURCE/prepare-commit-msg" ]; then
    cp "$GIT_HOOKS_SOURCE/prepare-commit-msg" "$GIT_HOOKS_DIR/prepare-commit-msg"
    chmod +x "$GIT_HOOKS_DIR/prepare-commit-msg"
    echo "    â†’ Git prepare-commit-msg hook copied from $GIT_HOOKS_SOURCE"
  fi
  
  if [ -f "$GIT_HOOKS_SOURCE/commit-msg" ]; then
    cp "$GIT_HOOKS_SOURCE/commit-msg" "$GIT_HOOKS_DIR/commit-msg"
    chmod +x "$GIT_HOOKS_DIR/commit-msg"
    echo "    â†’ Git commit-msg hook copied from $GIT_HOOKS_SOURCE"
  fi
  
  # Configure Git to use the global hooks directory for ALL repositories
  git config --global core.hooksPath "$GIT_HOOKS_DIR"
  echo "    â†’ Git global hooks path configured (applies to all repositories)"
  
  # Also keep the template directory for backwards compatibility
  mkdir -p "$HOME/.git_template/hooks"
  if [ -f "$GIT_HOOKS_DIR/prepare-commit-msg" ]; then
    cp "$GIT_HOOKS_DIR/prepare-commit-msg" "$HOME/.git_template/hooks/prepare-commit-msg"
  fi
  if [ -f "$GIT_HOOKS_DIR/commit-msg" ]; then
    cp "$GIT_HOOKS_DIR/commit-msg" "$HOME/.git_template/hooks/commit-msg"
  fi
  git config --global init.templateDir "$HOME/.git_template" 2>/dev/null || true
  echo "    â†’ Git template directory also configured for new repositories"
fi

echo "âœ… Dotfiles copied successfully!"
echo ""
echo "Files configured for:"
echo "  â€¢ Bash: .bash_profile, .bashrc, .bash_functions"
echo "  â€¢ Zsh:  .zshrc, .zprofile, .zsh_functions"
echo "  â€¢ Shared: .shared_shell_config"
